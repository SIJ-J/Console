#include <iostream>

using std::cout;
using std::cin;
using std::endl;

/*
	- 포인터란?
	 - 주소를 저장하는 변수 (포인터 변수)
	 - 모든 데이터는 메모리상에 특정한 공간에 저장되어 있음
	 - 기존의 우리가 알고있는 변수는 데이터를 저장하지만 포인터는 메모리 공간의 주소를 저장

	 - 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야함.
	 - 변수이름앞에 &연산자를 붙이면 해당 변수의 시작주소를 반환한다.
	 - 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 *연산자를 사용

	 & - 특정한 데이터의 메모리 상의 주소값을 알수있다.
	 * - &연산자가 어떤 데이터의 주소값을 얻어내는 연산자라면 주소값에서 해당 주소값에 대응되는 데이터를 가져온다.

	 포인터 변수는 주소만 저장하는 녀석이라며?
	 근데 왜 타입이 있음?

	 int num;
	 pointer(라는 타입이 있다고 가정할때) *p;
	 p = &num;

*/

int main()
{
	int* p;	// 포인터 변수 p선언

	int a = 2;
	p = &a;	// 변수 a의 주소 저장
	cout << "P의 값(변수 a의 주소값) : " << p << endl;
	cout << a << endl;
	cout << "*p의 값(a의 값) : " << *p << endl;

	*p = 100;
	cout << "*p의 값 변경 후 : " << *p << endl;

	int num;
	const int* pa = &num;
	/*
		const int * 
		 - const int형 변수를 가리킨다는 것이 아니라
	 	   int형 변수를 가리키는데 그 값을 절대로 바꾸지 말라는 뜻
		   즉, pa는 어떤 int형 변수를 가리키고 있고 const가 붙어있기 때문에 pa가 가리키는 변수의 값은 절대로 바뀌면 안된다는 뜻
	*/
	
	int b, c;
	int* const pb = &b;
	/*
		int * const
		 - 포인터가 가리키는 변수의 값은 변경할수 있지만
		   포인터가 저장하는 주소의 변경이 불가능
	*/

	int d = 10;
	int* p1 = &d;
	
	*p1 = 777;

	int** pp;
	pp = &p1;
	cout << "pp의 값 : (p의 주소값)" << pp << endl;

	cout << "*pp의 값 : (d의 주소값)" << *pp << endl;
	cout << "**pp의 값 : (d의 값)" << **pp << endl;

}